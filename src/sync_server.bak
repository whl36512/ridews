extern crate websocket;

use std::thread;
use self::websocket::sync::Server;
use self::websocket::{Message, OwnedMessage};

trait SyncServer {

fn process_msg(msg : &str) -> String {
		msg.to_string()
}
fn sync_server(url: &str) {
	let server = Server::bind(url).unwrap();

	for connection in server.filter_map(Result::ok) {
		thread::spawn(move || {
			let client = connection.accept().unwrap();

			let (mut receiver, mut sender) = client.split().unwrap();

			for message in receiver.incoming_messages() {
				let message = match message {
					Ok(message) => message,
					Err(e) => {
						println!("{:?}", e);
						let _ = sender.send_message(&Message::close());
						return;
					}
				};

				match message {
					OwnedMessage::Text(txt) => {
						let result= SyncServer::process_msg(&txt);
						sender.send_message(&OwnedMessage::Text(result)).unwrap()
						//sender.send_message(&OwnedMessage::Text(txt)).unwrap()
					}
					OwnedMessage::Binary(bin) => {
						sender.send_message(&OwnedMessage::Binary(bin)).unwrap()
					}
					OwnedMessage::Close(_) => {
						sender.send_message(&OwnedMessage::Close(None)).ok();
						return;
					}
					OwnedMessage::Ping(data) => {
						sender.send_message(&OwnedMessage::Pong(data)).unwrap();
					}
					_ => (),
				}
			}
		});
	}
}
}
